;***************************************************************************
;
;	    Filename: MidiMaster.asm
;	    Date: 11/05/2024
;	    File Version: 1
;	    Author: Owen Fujii
;	    Company: Idaho State University
;	    Description: The Program for the Master controller for the 
;			    midi bass guitar
;**************************************************************************
	
;*************************************************************************
; 
;	    Revision History:
;   
;	    Modified as listed
;	    Started 
;
;*************************************************************************
;  The Master will interpret the MIDI signal from UART and will 
;   then break up the info and then send this to the correseponding slave
;    
;	MIDI: <Control>, <Pitch>, <Velocity>    
;	    Upper Nibble: Control Byte
;	    Lower Nibble: Instrument Address = Default for testing 0x01
;	    Basic Control <upper> Bytes: 0x90 = Note ON
;				 0x80 = Note OFF
;				 0xF0 = Special function
;			  <Pitch> = xPPP PPPP // Note 0-127
;			  <Velocity> = xVVV VVVV // Attack 0-127
;    
;	Note Slaves: <Pitch>
;	    MPPP PPPP 
;		P = The pitch index from 0-127, min is E1//28, max is D#4//63
;		M = Mute control boolean based on upper control, 0 = Mute
;		    Pitch of E string = E1 to C3
;		    Pitch of A string = A2 to F3
;		    Pitch of D string = D2 to A#3
;		    Pitch of G string = G2 to D#4
;
;	Pluck Slaves: <Velocity>, <String>
;	    xVVV VVVV,FxxN  SSSS 
;		V = How Aggresive to attack string
;		F = select finger or pick, 0 = finger
;		N = disable note
;		S = which string to pluck,E = bit0,A = bit1,D = bit2,G = bit3
;*************************************************************************    
; Other notes about program
;	    
;	As MIDI represents note solely based upon their value chromatically
;	, such as E1, it does not give enough information to select where to 
;	play the note on instruments like the bass guitar which have the same
;	note on mulitple strings on different frets. The result is the master
;	uses mathmatical calculations to select which control slave would be 
;	best to use for a given note. 
;
;	About the auto selection of strings. the general rule is that 
;	the current string is prioritized for notes that are within 5 notes
;	up or down from the current position. When within the range of 5 to 10
;	the sister string above or below is prioritized. In cases where an 
;	octave note is sent the second string above or below is used as this
;	generally how most bass players handle octave notes. in all other cases
;	the note is prioritized sequentially based upon the E string until its
;	limits are met at which each string is tested until it is found on a 
;	valid strings.
;    
    ; PIC16F1788 Configuration Bit Settings

; Assembly source line config statements
    
	#INCLUDE "p16f1788.inc"
	#INCLUDE <MidiMasterSetup.inc>
	#INCLUDE <MidiMasterEEWRITE.inc>
	#INCLUDE <MidiMasterEEREAD.inc>
	#INCLUDE <MidiMasterPOPout.inc>
	#INCLUDE <MidiMasterPUSHin.inc>
	#INCLUDE <MidiMasterI2CWRITE.inc>
	

; CONFIG1
; __config 0xE9A4
 __CONFIG _CONFIG1, _FOSC_INTOSC & _WDTE_OFF & _PWRTE_OFF & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOREN_OFF & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_ON
; CONFIG2
; __config 0xDFFF
 __CONFIG _CONFIG2, _WRT_OFF & _VCAPEN_OFF & _PLLEN_ON & _STVREN_ON & _BORV_LO & _LPBOR_OFF & _LVP_OFF

 
 ;*********************
 ;Define Constants
 ;*********************
	; RESERVED ADDRESSES
	; H'20' WORKING SAVE
	; H'21' STATUS SAVE
	; H'30' ADDRESS FOR I2C SLAVE
	; H'31' BYTE 1 FOR I2C TRANSMIT
	; H'32' BYTE 2 FOR I2C TRANSMIT
	; H'33' FLAG FOR TWO BYTE TRANSMIT 
 
	; NOTE SLAVE ADDRESSES
	    ESLAVE	    EQU H'022' ; SLAVE IS ADDRESSED // 0X01
	    ASLAVE	    EQU H'023' ; SLAVE IS ADDRESSED // 0X02
	    DSLAVE	    EQU H'024' ; SLAVE IS ADDRESSED // 0X04
	    GSLAVE	    EQU H'025' ; SLAVE IS ADDRESSED // 0X08
	; PLUCKING/PICK SLAVE ADDRESSES
	    PLUCKSLAVE	    EQU H'026' ; SLAVE IS ADDRESSED // OX10
	; I2C REGISTERS
	    ADDRESS	    EQU H'030'
	    I2CBYTE	    EQU H'031'
	    I2CBYTE2	    EQU H'032'
	    FLAG	    EQU H'033'
	; ADDITIONAL GPR REGISTERS
	    ; STORAGE AND RECIEVE REGISTERS
	    CTLBYTE	    EQU H'034'
	    PBYTE	    EQU H'035'
	    VBYTE	    EQU H'036'
	    BUFFER	    EQU H'037'
	    TEMP	    EQU H'038'
	    ; NOTE STORAGE NUMBERS
	    MIDIADD	    EQU H'039'
	    LASTNOTE	    EQU H'040'
	    LASTADD	    EQU H'041'
	    LOWNOTE	    EQU	H'042'
	    HIGHNOTE	    EQU H'043'
	    ; STORAGE FOR LIMITS OF EACH STRING
	    ; EMIN IS LOWEST NOTE
	    EMAX	    EQU H'044'
	    AMIN	    EQU H'045'
	    AMAX	    EQU H'046'
	    DMIN	    EQU H'047'
	    DMAX	    EQU H'048'
	    GMIN	    EQU H'049'
	    ; GMAX IS HIGHEST NOTE
	    
    ORG H'000'					
    GOTO SETUP					;RESET CONDITION GOTO SETUP
    ORG H'004'
    GOTO INTER
 
    
SETUP
    ; BASIC SETUP HERE
    BANKSEL OSCSTAT
    BTFSC OSCSTAT,PLLR	    ; WAIT FOR PLL TO BE UP AND RUNNING
    GOTO $-1
    BANKSEL OSCCON
    CLRF OSCCON
    MOVLW H'070'	    ; SET OSCILLATOR FOR 8MHZ AND LOOK AT CONFIG BITS
    MOVWF OSCCON
    BSF OSCCON,SPLLEN	    ; ENABLE 4X PLL FOR 32MHZ CLOCK
    BANKSEL OSCSTAT
    BTFSC OSCSTAT,OSTS	    ; WAIT FOR OSSCILATOR TO BE READY
    GOTO $-1
    CALL START		    ; CALL SETUP INCLUDE
    ; EUART SETUP HERE
    BANKSEL BAUD1CON
    CLRF BAUD1CON	    ; CLEAR BAUD RATE CTL FOR 8-BIT ASYNC
    BANKSEL SP1BRGL
    CLRF SP1BRGL
    MOVLW H'00F'	    ; SET BAUD FOR ASYNC 31.25K
    MOVWF SP1BRGL
    BANKSEL SPBRGH	    ; CLEAR UPPER REGISTER // PRECAUSION
    CLRF SPBRGH
    BANKSEL TXSTA
    CLRF TXSTA		    ; CLEAR TRANSMIT REGISTER
    BANKSEL RCREG
    CLRF RCREG
    BANKSEL RCSTA
    CLRF RCSTA	
    MOVLW H'0B0'	    ; SET FOR CONTINUOUS RECIEVE
    MOVWF RCSTA
    BANKSEL PIE1
    BSF PIE1,RCIE	    ; ENABLE RECIEVE INTERRUPT FOR UART
    ; PIN ASSIGNMENTS
    BANKSEL APFCON1
    CLRF APFCON1	    ; SET PINS
    BANKSEL APFCON2
    CLRF APFCON2	    ; SET PINS 
    ; I2C SETUP HERE
    BANKSEL SSP1CON1
    MOVLW H'028'	    ; SET 7 BIT MASTER WITH ADJUSTABLE CLOCK
    MOVWF SSP1CON1
    BANKSEL SSP1ADD
    MOVLW H'013'	    ; SET 400K I2C CLOCK
    MOVWF SSP1ADD
    BANKSEL SSP1CON2
    CLRF SSP1CON2	    ; CLEAR REGISTER
    BANKSEL SSP1CON3
    CLRF SSP1CON3	    ; CLEAR REGISTER MOST FEATURES FOR SLAVES
   ; BANKSEL PIE1
    ; SET ADDRESSES FOR SLAVES
    BANKSEL PORTB
    MOVLW H'002'
    MOVWF ESLAVE	    ; SET ADDRESS OF 0X01 AND WRITE
    MOVLW H'004'
    MOVWF ASLAVE	    ; SET ADDRESS OF 0X02 AND WRITE
    MOVLW H'008'
    MOVWF DSLAVE	    ; SET ADDRESS OF 0X04 AND WRITE
    MOVLW H'010'
    MOVWF GSLAVE	    ; SET ADDRESS OF 0X08 AND WRITE
    MOVLW H'020'
    MOVWF PLUCKSLAVE	    ; SET ADDRESS OF 0X10 AND WRITE
    ; FINAL SETUP
    CLRF CTLBYTE	    ; CLEAR STORAGE AND FLAG REGISTERS
    CLRF PBYTE
    CLRF VBYTE
    CLRF BUFFER
    CLRF LASTNOTE
    CLRF LASTADD
    MOVLW H'002'
    MOVWF LASTADD	    ; SET THE STARTING ADDRESS TO BE ESLAVE
    ; SET MIN AND MAX NOTES
    MOVLW H'01C'
    MOVWF LOWNOTE	    ; E1 // 28 MIDI
    MOVLW H'040'
    MOVWF HIGHNOTE	    ; D#4 // 63 MIDI BUT IS ONE MORE FOR CORRECT MATH
    ; SET MIN AND MAX ON A PER STRING BASIS
    MOVLW H'030'	    
    MOVWF EMAX		    ; C3 // 48 MIDI // MAX FOR E STRING
    MOVLW H'021'
    MOVWF AMIN		    ; A2 // 33 MIDI // MIN FOR A STRING
    MOVLW H'035'
    MOVWF AMAX		    ; F3 // 53 MIDI // MAX FOR E STRING
    MOVLW H'026'
    MOVWF DMIN		    ; D2 // 38 MIDI // MIN FOR D STRING
    MOVLW H'03A'
    MOVWF DMAX		    ; A#3// 58 MIDI // MAX FOR D STRING
    MOVLW H'02B'
    MOVWF GMIN		    ; G3 // 43 MIDI // MIN FOR G STRING
    ; SET MIDI DEVICE ADDRESS
    MOVFW PORTB		    ; READ EXTERNAL SWITCH
    MOVWF MIDIADD	    ; SET MIDI DEVICE ADDRESS
    BSF INTCON,GIE	    ; ENABLE INTERRUPTS
    BSF INTCON,PEIE 
    BSF INTCON,IOCIE	    ; INTERRUPT ON CHANGE
    GOTO MAIN
    
MAIN
    BANKSEL PORTB
    BTFSS BUFFER,2
    GOTO MAIN
    BSF BUFFER,4	    ; SET CURRENT DATA 
    ; IS THE PITCH WITHIN THE BOUNDS OF BASS GUITAR
    MOVFW LOWNOTE
    SUBWF PBYTE,0
    BTFSS STATUS,C  ; IF X - 28 IS NEGATIVE
    GOTO BAIL	    ; THEN OUT OF BOUNDS	
    MOVFW HIGHNOTE
    SUBWF PBYTE,0   ; IF X - 63 IS POSITIVE
    BTFSC STATUS,C  ; THEN OUT OF BOUNDS
    GOTO BAIL
    ; EVALUATION OF WHAT STRINGS TO USE WHEN CURRENT NOTE IS 
    ; GREATER THAN THE LAST
    MOVFW LASTNOTE
    BCF STATUS,Z
    SUBWF PBYTE,0
    BTFSC STATUS,Z
    GOTO I2CSEND    ; IF THE NOTE IS SAME AS LAST SEND DATA
    BTFSS STATUS,C  ; IF POSITIVE RESULT SKIP 
    GOTO LOWERNOTE  ; OTHERWISE EVALUTE FOR LOWER NOTE
    ; TEST STATEMENT 1 FOR NOTE x<5
    MOVFW LASTNOTE
    ADDLW H'003'
    SUBWF PBYTE,0
    BTFSS STATUS,C  ; IF UNDER 5 PLAY ON THE CURRENT STRING
    GOTO CHECKUP 
    ; TEST STATEMENT 2 FOR NOTE 5<x>10
    MOVFW LASTNOTE
    ADDLW H'008'
    SUBWF PBYTE,0
    BTFSS STATUS,C  ; IF UNDER PLAY NOTE ONE STRING UP
    GOTO INCSTRING
    ; TEST STATEMENT 3 FOR OCTAVE NOTES LAST + 12
    MOVFW LASTNOTE
    ADDLW H'00C'	    ; ADD 12 // OCTAVE
    BCF STATUS,Z
    SUBWF PBYTE,0
    BTFSC STATUS,Z
    GOTO OCTAVE
    ; FINAL STATEMENT
    ; EVALUATE IF NOTE IS VALID FOR E STRING
FINDNOTE
    MOVFW PBYTE
    SUBWF EMAX,0
    BTFSS STATUS,C  ; IF RESULT IT GREATER THAN MOVE TO A STRING
    GOTO MOVETOA
    ; IF VALID SELECT E STRING OTHERWISE TEST A STRING
    MOVFW ESLAVE
    MOVWF LASTADD
    GOTO I2CSEND
    ;
MOVETOA
    MOVFW PBYTE
    SUBWF AMAX,0
    BTFSS STATUS,C
    GOTO MOVETOD
    ; IF VALID SELECT A STRING OTHERWISE TEST D STRING
    MOVFW ASLAVE
    MOVWF LASTADD
    GOTO I2CSEND
MOVETOD
    MOVFW PBYTE
    SUBWF DMAX,0
    BTFSS STATUS,C
    GOTO MOVETOG
    ; IF VALID SELECT D STRING OTHERWISE MOVE TO G STRING
    ;
    MOVFW DSLAVE
    MOVWF LASTADD
    GOTO I2CSEND
MOVETOG
    MOVFW GSLAVE
    MOVWF LASTADD
    GOTO I2CSEND
    ; WHEN G STRING IS SELECTED THERE IS NO MORE NOTES ABOVE THIS STRING
    

INCSTRING
    BTFSC LASTADD,4
    GOTO I2CSEND    ; IF ON THE G STRING STAY ON STRING
    BCF STATUS,C    ; CLEAR CARRY BIT
    RLF LASTADD,1   ; INCREMENT SLAVE ADDRESS BY ONE UP
    GOTO CHECKUP
    
OCTAVE
    BTFSC LASTADD,3
    GOTO I2CSEND    ; IF ON THE G STRING STAY ON STRING
    BCF STATUS,C 
    RLF LASTADD,1   ; INCREMENT SLAVE ADDRESS BY ONE UP
    BTFSC LASTADD,3
    GOTO I2CSEND    ; IF INCREMENTED TO G STRING STOP AND SEND NOTE
    RLF LASTADD,1   ; INCREMENT SLAVE ADDRESS TO BE TWO MORE TOTAL
    GOTO CHECKUP	
    
 
CHECKUP    
    BTFSC LASTADD,0
    GOTO VALIDE
    BTFSC LASTADD,1
    GOTO VALIDA
    BTFSC LASTADD,2
    GOTO VALIDD	    ; DO NOT NEED TO EVAL PAST D STRING
    GOTO I2CSEND    ;     
    
VALIDE
    ; LOWER LIMIT IS ALREADY CAUGHT // ONLY EVAL MAX
    MOVFW PBYTE
    SUBWF EMAX,0
    BTFSS STATUS,C  ; IF RESULT IT GREATER THAN MOVE TO A STRING
    GOTO I2CSEND
    BCF STATUS,C    ; CLEAR CARRY BEFORE ROTATION
    RLF LASTADD,1   
    GOTO I2CSEND    
     
VALIDA
    MOVFW PBYTE
    SUBWF AMAX,0
    BTFSS STATUS,C  ; IF OUT OF BOUNDS OF A STRING MOVE TO D STRING
    GOTO I2CSEND
    BCF STATUS,C    ; CLEAR CARRY BEFORE ROTATION
    RLF LASTADD,1   
    GOTO I2CSEND    
    
VALIDD
    MOVFW PBYTE
    SUBWF DMAX,0
    BTFSS STATUS,C  ; IF OUT OF BOUNDS OF D STRING MOVE TO G STRING
    GOTO I2CSEND
    BCF STATUS,C    ; CLEAR CARRY BEFORE ROTATION
    RLF LASTADD,1   
    GOTO I2CSEND    
    
LOWERNOTE  
    ; STATEMENT 1 TEST FOR NOTE LOWER THAN CURRENT
    MOVLW H'05'
    SUBWF LASTNOTE,0	; REDUCE LAST NOTE BY 5
    SUBWF PBYTE,0
    BTFSC STATUS,C
    GOTO LOWCHECK	; IF WITHIN FIVE USE SAME STRING
    ; STATEMENT 2 CHECK FOR NOTE 10 LOWER THAN CURRENT
    MOVLW H'0A'
    SUBWF LASTNOTE,0
    SUBWF PBYTE,0
    BTFSC STATUS,C  
    GOTO DECSTRING
    ; STATEMENT 3 CHECK FOR OCTAVE NOTE DOWN
    MOVLW H'0C'
    SUBWF LASTNOTE,0
    SUBWF PBYTE,0
    BTFSC STATUS,Z
    GOTO OCTAVEDOWN
    ; FINAL STATEMENT
    GOTO FINDNOTE
    
LOWCHECK
    BTFSC LASTADD,3
    GOTO DOWNG		; CHECK THAT NOTE IS NOT OUT OF BOUNDS OF G
    BTFSC LASTADD,2
    GOTO DOWND		; CHECK THAT NOTE IS NOT OUT OF BOUNDS OF D
    BTFSC LASTADD,1
    GOTO DOWNA		; CHECK THAT NOTE IS NOT OUT OF BOUNDS OF A
    GOTO I2CSEND	; IF ON E STRING GO TO SEND // LOW NOTE LIMIT CAUGHT
    
DOWNG
    MOVFW GMIN
    SUBWF PBYTE,0
    BTFSC STATUS,C
    GOTO I2CSEND
    BCF STATUS,C	; CLEAR CARRY BEFORE ROTATION
    RRF LASTADD,1	; IF NOTE IS LOWER THAN G MIN MOVE TO D STRING
    GOTO I2CSEND
    
DOWND
    MOVFW DMIN
    SUBWF PBYTE,0
    BTFSC STATUS,C
    GOTO I2CSEND
    BCF STATUS,C	; CLEAR CARRY BEFORE ROTATION
    RRF LASTADD,1	; IF NOTE IS LOWER THAN G MIN MOVE TO D STRING
    GOTO I2CSEND
   
DOWNA
    MOVFW AMIN
    SUBWF PBYTE,0
    BTFSC STATUS,C
    GOTO I2CSEND
    BCF STATUS,C	; CLEAR CARRY BEFORE ROTATION
    RRF LASTADD,1	; IF NOTE IS LOWER THAN G MIN MOVE TO D STRING
    GOTO I2CSEND
    
DECSTRING
    BTFSC LASTADD,0
    GOTO I2CSEND	; IF LAST ADDRESS WAS E STRING STAY ON STRING
    BCF STATUS,C
    RRF LASTADD,1	; SHIFT TO THE RIGHT ONE STRING
    BTFSC LASTADD,3	; EVALUATE THAT NOTE IS VALID FOR EACH STRING
    GOTO DOWNG
    BTFSC LASTADD,2
    GOTO DOWND
    BTFSC LASTADD,1
    GOTO DOWNA
    GOTO I2CSEND
    
DOUBLEDOWNG
    MOVFW GMIN
    SUBWF PBYTE,0
    BTFSC STATUS,C
    GOTO I2CSEND	; IF WITHIN RANGE STAY ON STRING
    RRF LASTADD,1	
    RRF LASTADD,1	; MOVE DOWN TO A STRING
    GOTO I2CSEND
    
DOUBLEDOWND
    MOVFW DMIN
    SUBWF PBYTE,0
    BTFSC STATUS,C
    GOTO I2CSEND	; IF WITHIN RANGE STAY ON STRING
    MOVLW H'002'	; MOVE DOWN TO E STRING
    MOVWF LASTADD
    GOTO I2CSEND
    
DOUBLEDOWNA
    MOVFW AMIN
    SUBWF PBYTE,0
    BTFSC STATUS,C
    GOTO I2CSEND	; IF WITHIN RANGE STAY ON STRING
    MOVLW H'002'	; MOVE DOWN TO E STRING
    MOVWF LASTADD
    GOTO I2CSEND
    
OCTAVEDOWN
    BTFSC LASTADD,0
    GOTO I2CSEND	; IF LAST ADDRESS WAS E STRING STAY ON STRING
    BCF STATUS,C
    RRF LASTADD,1
    BTFSC LASTADD,0
    GOTO I2CSEND	; IF ROTATED TO E STRING END EARLY AND SEND NOTE
    RRF LASTADD,1
    GOTO I2CSEND	 ; SHIFT STRING UP TWICE FOR OCTAVE IN POSSIBLE
    
BADADD
    CLRF BUFFER		; CALL WHEN AN ILLEGAL ADDRESS IS CALLED
    CLRF PBYTE		; COMPLETELY CLEARS STATE AND DOES NOT EXECUTE
    CLRF VBYTE		; ANY OPERATIONS WITH SLAVES
    CLRF CTLBYTE	; RESTARTS FRESH
    CLRF LASTADD
    MOVLW H'002'
    MOVWF LASTADD
    GOTO MAIN
    
    
I2CSEND
    ; SEND TO PITCH SLAVE(S)
    BTFSC LASTADD,0	    ; CHECK IF LSB IS SET
    GOTO BADADD
    MOVFW LASTADD
    MOVWF ADDRESS	    ; SET THE ADDRESS OF THE SLAVE
    MOVF PBYTE,0	    ; MOVE TO WORKING
    MOVWF LASTNOTE	    ; STORE CURRENT NOTE
    MOVWF I2CBYTE	    ; MOVE TO BYTE
    BCF CTLBYTE,0
    BCF CTLBYTE,1
    BCF CTLBYTE,2
    BCF CTLBYTE,3
    MOVLW H'090'
    BCF STATUS,Z
    SUBWF CTLBYTE,0
    BTFSC STATUS,Z	    ; CHECK IF THE BIT FOR A 9 HAS BEEN RECIEVED
    BSF I2CBYTE,7	    ; SET NOTE TO BE PLAYED
    CLRF FLAG		    ; CLEAR FLAG FOR SINGLE TRANSMISSION
    CALL I2CWRITE	    ; CALL WRITE
    ; SEND TO PLUCK SLAVE
    BTFSC PORTA,1	    ; WAIT FOR SLAVE TO CONFIRM POSITION.
    GOTO $-1		
    MOVFW PLUCKSLAVE
    MOVWF ADDRESS	    ; MOVE PLUCK SLAVE ADDRESS TO TRANSMIT
    MOVF VBYTE,0	    
    MOVWF I2CBYTE   
    MOVFW LASTADD	    ; MOVE ADDRESS TO TEMP REGISTER
    MOVWF TEMP
    BCF STATUS,C
    RRF TEMP,1		    ; ROTATE RIGHT TO GET RIGHT STRING 
    BTFSC CTLBYTE,4	    ; TELL SLAVE WHETHER NOTE ON // OFF WAS ISSUED
    BSF TEMP,4		    
    MOVFW TEMP		    ; SET FOR FINGER STYLE AND SLAVE TO BE USED
    MOVWF I2CBYTE2
    BSF FLAG,0		    ; SET FLAG FOR TWO BYTE
    CALL I2CWRITE
    CLRF BUFFER
    GOTO MAIN
    
BAIL
    CLRF BUFFER		    ; CLEAR ALL SAVED STATUS
    CLRF PBYTE		    ; CALLED WHEN OUT OF BOUNDS
    CLRF CTLBYTE	    ; NOTES ARE CALLED
    CLRF VBYTE
    GOTO MAIN
    
    
INTER
    BANKSEL INTCON 
    BCF INTCON,GIE
    BCF INTCON,PEIE
    BCF INTCON,IOCIE
    CALL PUSHIN
    BTFSC PIR1,RCIF	    ; CHECK EUART RECIEVE FLAG
    CALL RECIEVE    
    BTFSC INTCON,IOCIF	    ; CHECK PORT INTERRUPT FLAG
    CALL ADDRESSUP
    BANKSEL INTCON
  ;  CLRF PORTB
    CLRF PIR1
    BSF INTCON,GIE	    ; REENABLE INTERRUPTS
    BSF INTCON,PEIE
    BSF INTCON,IOCIE
    CALL POPOUT
    RETFIE
    
RECIEVE
    BANKSEL RCREG
    MOVF RCREG,0
    BANKSEL PORTB
    BSF PORTB,1
    MOVWF TEMP
    BTFSC BUFFER,4	    
    RETURN
    BTFSC BUFFER,1
    GOTO BYTE2
    BTFSC BUFFER,0
    GOTO BYTE1
    MOVWF CTLBYTE	    ; VERIFY MIDI ADDRESS
    BCF CTLBYTE,4	    ; IGNORE COMMAND NIBBLE
    BCF CTLBYTE,5
    BCF CTLBYTE,6
    BCF CTLBYTE,7
    MOVF CTLBYTE,0
    BCF STATUS,Z
    SUBWF MIDIADD,0	    ; VERIFY ADDRESS
    BTFSS STATUS,Z
    RETURN		    ; RETURN IF NOT VALID ADDRESS
    MOVF TEMP,0
    MOVWF CTLBYTE	    ; STORE CONTROL BYTE
    BSF BUFFER,0
    RETURN
    
BYTE1
    MOVF TEMP,0
    MOVWF PBYTE		    ; STORE PITCH BYTE
    BSF BUFFER,1
    RETURN
    
BYTE2
    MOVF TEMP,0
    MOVWF VBYTE		    ; STORE VELOCITY BYTE
    BSF BUFFER,2
    RETURN
    
ADDRESSUP
    MOVFW PORTB
    MOVWF MIDIADD	    ; UPDATE MIDI ADDRESS WHEN PORTB CHANGES
    RETURN
 
END
